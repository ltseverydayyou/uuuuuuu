local passes, fails, undefined, existsOnly, missing, optionalMissing = 0, 0, 0, 0, 0, 0
local running = 0

local list_pass = {}
local list_fail = {}
local list_exists_only = {}
local list_missing = {}
local list_alias_missing = {}
local list_optional_missing = {}

local function getGlobal(path)
	local value = getfenv(0)
	while value ~= nil and path ~= "" do
		local name, nextValue = string.match(path, "^([^.]+)%.?(.*)$")
		value = value[name]
		path = nextValue
	end
	return value
end

local function test(name, aliases, callback, optional)
	optional = optional == true
	running += 1
	task.spawn(function()
		local mainValue = getGlobal(name)
		local mainExists = mainValue ~= nil

		if not callback then
			if mainExists then
				existsOnly += 1
				table.insert(list_exists_only, name)
				print("⏺️ " .. name .. " • Exists but behavior is not tested")
			else
				if optional then
					optionalMissing += 1
					table.insert(list_optional_missing, name)
					print("⏺️ " .. name .. " • Optional feature not provided")
				else
					fails += 1
					missing += 1
					table.insert(list_missing, name)
					warn("⛔ " .. name .. " • Global is missing in this environment")
				end
			end
		else
			if not mainExists then
				if optional then
					optionalMissing += 1
					table.insert(list_optional_missing, name)
					print("⏺️ " .. name .. " • Optional feature not provided")
				else
					fails += 1
					missing += 1
					table.insert(list_missing, name)
					warn("⛔ " .. name .. " • Global is missing in this environment")
				end
			else
				local success, message = pcall(callback)
				if success then
					passes += 1
					table.insert(list_pass, name .. (message and (" • " .. message) or ""))
					print("✅ " .. name .. (message and (" • " .. message) or ""))
				else
					fails += 1
					table.insert(list_fail, name .. " • " .. tostring(message))
					warn("⛔ " .. name .. " failed: " .. tostring(message))
				end
			end
		end

		local undefinedAliases = {}
		for _, alias in ipairs(aliases) do
			if getGlobal(alias) == nil then
				table.insert(undefinedAliases, alias)
			end
		end

		if #undefinedAliases > 0 then
			undefined += 1
			table.insert(list_alias_missing, name .. " -> " .. table.concat(undefinedAliases, ", "))
			warn("⚠️ Missing alias(es) for " .. name .. ": " .. table.concat(undefinedAliases, ", "))
		end

		running -= 1
	end)
end

print("\nUNC Environment Check")
print("✅ - Pass (exists and behavior works)")
print("⛔ - Fail (missing or behavior broken)")
print("⏺️ - Exists but not behavior-tested / optional missing")
print("⚠️ - Missing aliases\n")

task.defer(function()
	repeat task.wait() until running == 0

	local function sortList(t)
		table.sort(t, function(a, b) return a < b end)
	end

	sortList(list_pass)
	sortList(list_fail)
	sortList(list_exists_only)
	sortList(list_missing)
	sortList(list_alias_missing)
	sortList(list_optional_missing)

	local testedTotal = passes + fails
	local rate = testedTotal > 0 and math.round(passes / testedTotal * 100) or 0
	local outOf = passes .. " out of " .. testedTotal

	print("\nUNC Summary")
	print("✅ Passes: " .. passes)
	print("⛔ Fails: " .. fails)
	print("⏺️ Exists but untested: " .. existsOnly)
	print("❌ Missing required globals: " .. missing)
	print("⏺️ Missing optional globals: " .. optionalMissing)
	print("⚠️ Globals with missing aliases: " .. undefined)
	print("Tested success rate: " .. rate .. "% (" .. outOf .. ")\n")

	local verdict
	if testedTotal == 0 then
		verdict = "No UNC functions were actually tested. Almost everything is missing."
	elseif rate >= 90 and fails == 0 and missing == 0 then
		verdict = "Excellent UNC compatibility: almost everything matches and behaves correctly."
	elseif rate >= 80 and fails == 0 then
		verdict = "Very good UNC compatibility: core features behave correctly, some globals or aliases missing."
	elseif rate >= 60 then
		verdict = "Decent UNC compatibility: usable, but several functions are missing or behave differently."
	elseif rate >= 30 then
		verdict = "Poor UNC compatibility: many UNC features fail or are missing."
	else
		verdict = "Very bad UNC compatibility: this environment barely matches UNC."
	end

	print("Verdict: " .. verdict .. "\n")

	--[[if #list_pass > 0 then
		print("✅ Existing globals that passed behavior tests:")
		print("  "..table.concat(list_pass, ", "))
		print("")
	end

	if #list_fail > 0 then
		print("⛔ Existing globals that failed behavior tests:")
		print("  "..table.concat(list_fail, ", "))
		print("")
	end

	if #list_exists_only > 0 then
		print("⏺️ Existing globals with no behavior test (existence only):")
		print("  "..table.concat(list_exists_only, ", "))
		print("")
	end]]

	if #list_missing > 0 then
		print("❌ Completely missing required globals:")
		print("  "..table.concat(list_missing, ", "))
		print("")
	end

	if #list_optional_missing > 0 then
		print("⏺️ Missing optional (executor-specific) globals:")
		print("  "..table.concat(list_optional_missing, ", "))
		print("")
	end

	--[[if #list_alias_missing > 0 then
		print("⚠️ Globals with missing aliases:")
		print("  "..table.concat(list_alias_missing, " | "))
		print("")
	end]]
end)

local function shallowEqual(t1, t2)
	if t1 == t2 then
		return true
	end

	local UNIQUE_TYPES = {
		["function"] = true,
		["table"] = true,
		["userdata"] = true,
		["thread"] = true,
	}

	for k, v in pairs(t1) do
		if UNIQUE_TYPES[type(v)] then
			if type(t2[k]) ~= type(v) then
				return false
			end
		elseif t2[k] ~= v then
			return false
		end
	end

	for k, v in pairs(t2) do
		if UNIQUE_TYPES[type(v)] then
			if type(t2[k]) ~= type(v) then
				return false
			end
		elseif t1[k] ~= v then
			return false
		end
	end

	return true
end

if isfolder and makefolder and delfolder then
	if isfolder(".tests") then
		delfolder(".tests")
	end
	makefolder(".tests")
end

test("appendfile", {}, function()
	writefile(".tests/appendfile.txt", "su")
	appendfile(".tests/appendfile.txt", "cce")
	appendfile(".tests/appendfile.txt", "ss")
	assert(readfile(".tests/appendfile.txt") == "success", "Did not append the file")
end)

test("fireclickdetector", {}, function()
	local detector = Instance.new("ClickDetector")
	fireclickdetector(detector, 50, "MouseHoverEnter")
end)

test("fireproximityprompt", {}, function()
	local part = Instance.new("Part")
	part.Anchored = true
	part.CanCollide = false
	part.Position = Vector3.new(0, 5000, 0)
	part.Parent = workspace

	local prompt = Instance.new("ProximityPrompt")
	prompt.ActionText = "UNC_TEST"
	prompt.ObjectText = "UNC"
	prompt.Parent = part

	local triggered = false
	prompt.Triggered:Connect(function()
		triggered = true
	end)

	local ok, err = pcall(fireproximityprompt, prompt)
	assert(ok, err or "fireproximityprompt errored")
	task.wait(0.1)
	assert(triggered, "fireproximityprompt did not trigger the prompt")

	part:Destroy()
end)

test("firetouchinterest", {}, function()
	local plrs = game:GetService("Players")
	local lp = plrs.LocalPlayer
	if not lp then
		return "LocalPlayer missing; cannot touch-test"
	end

	local char = lp.Character or lp.CharacterAdded:Wait()
	local root = char:FindFirstChild("HumanoidRootPart") or char:FindFirstChildWhichIsA("BasePart")
	if not root then
		return "No character root part; cannot touch-test"
	end

	local part = Instance.new("Part")
	part.Size = Vector3.new(4, 4, 4)
	part.Anchored = true
	part.CanCollide = true
	part.Position = root.Position + Vector3.new(0, 5000, 0)
	part.Parent = workspace

	local touched = false
	local touchEnded = false

	part.Touched:Connect(function(hit)
		if hit == root then
			touched = true
		end
	end)

	part.TouchEnded:Connect(function(hit)
		if hit == root then
			touchEnded = true
		end
	end)

	local ok1, err1 = pcall(firetouchinterest, root, part, 0)
	assert(ok1, err1 or "firetouchinterest (touch) errored")
	task.wait(0.05)

	local ok2, err2 = pcall(firetouchinterest, root, part, 1)
	assert(ok2, err2 or "firetouchinterest (untouch) errored")
	task.wait(0.05)

	if not touched or not touchEnded then
		return "Events not observed; implementation may be stubbed or limited"
	end

	part:Destroy()
end)

test("cache.invalidate", {}, function()
	local container = Instance.new("Folder")
	local part = Instance.new("Part", container)
	cache.invalidate(container:FindFirstChild("Part"))
	assert(part ~= container:FindFirstChild("Part"), "Reference `part` could not be invalidated")
end)

test("cache.iscached", {}, function()
	local part = Instance.new("Part")
	assert(cache.iscached(part), "Part should be cached")
	cache.invalidate(part)
	assert(not cache.iscached(part), "Part should not be cached")
end)

test("cache.replace", {}, function()
	local part = Instance.new("Part")
	local fire = Instance.new("Fire")
	cache.replace(part, fire)
	assert(part ~= fire, "Part was not replaced with Fire")
end)

test("checkcaller", {}, function()
	assert(checkcaller(), "Main scope should return true")
end)

test("cleardrawcache", {}, function()
	cleardrawcache()
end)

test("clonefunction", {}, function()
	local function testf()
		return "success"
	end
	local copy = clonefunction(testf)
	assert(testf() == copy(), "The clone should return the same value as the original")
	assert(testf ~= copy, "The clone should not be equal to the original")
end)

test("cloneref", {}, function()
	local part = Instance.new("Part")
	local clone = cloneref(part)
	assert(part ~= clone, "Clone should not be equal to original")
	clone.Name = "Test"
	assert(part.Name == "Test", "Clone should have updated the original")
end)

test("compareinstances", {}, function()
	local part = Instance.new("Part")
	local clone = cloneref(part)
	assert(part ~= clone, "Clone should not be equal to original")
	assert(compareinstances(part, clone), "Clone should be equal to original when using compareinstances")
end)

test("crypt.base64decode", {"crypt.base64.decode", "crypt.base64_decode", "base64.decode", "base64_decode"}, function()
	assert(crypt.base64decode("dGVzdA==") == "test", "Base64 decoding failed")
end)

test("crypt.base64encode", {"crypt.base64.encode", "crypt.base64_encode", "base64.encode", "base64_encode"}, function()
	assert(crypt.base64encode("test") == "dGVzdA==", "Base64 encoding failed")
end)

test("crypt.decrypt", {}, function()
	local key, iv = crypt.generatekey(), crypt.generatekey()
	local encrypted = crypt.encrypt("test", key, iv, "CBC")
	local decrypted = crypt.decrypt(encrypted, key, iv, "CBC")
	assert(decrypted == "test", "Failed to decrypt raw string from encrypted data")
end)

test("crypt.encrypt", {}, function()
	local key = crypt.generatekey()
	local encrypted, iv = crypt.encrypt("test", key, nil, "CBC")
	assert(iv, "crypt.encrypt should return an IV")
	local decrypted = crypt.decrypt(encrypted, key, iv, "CBC")
	assert(decrypted == "test", "Failed to decrypt raw string from encrypted data")
end)

test("crypt.generatebytes", {}, function()
	local size = math.random(10, 100)
	local bytes = crypt.generatebytes(size)
	assert(#crypt.base64decode(bytes) == size, "The decoded result should be " .. size .. " bytes long (got " .. #crypt.base64decode(bytes) .. " decoded, " .. #bytes .. " raw)")
end)

test("crypt.generatekey", {}, function()
	local key = crypt.generatekey()
	assert(#crypt.base64decode(key) == 32, "Generated key should be 32 bytes long when decoded")
end)

test("crypt.hash", {}, function()
	local algorithms = {"sha1", "sha384", "sha512", "md5", "sha256", "sha3-224", "sha3-256", "sha3-512"}
	for _, algorithm in ipairs(algorithms) do
		local hash = crypt.hash("test", algorithm)
		assert(hash, "crypt.hash on algorithm '" .. algorithm .. "' should return a hash")
	end
end)

test("debug.getconstant", {}, function()
	local function testf()
		print("Hello, world!")
	end
	assert(debug.getconstant(testf, 1) == "print", "First constant must be print")
	assert(debug.getconstant(testf, 2) == nil, "Second constant must be nil")
	assert(debug.getconstant(testf, 3) == "Hello, world!", "Third constant must be 'Hello, world!'")
end)

test("debug.getconstants", {}, function()
	local function testf()
		local num = 5000 .. 50000
		print("Hello, world!", num, warn)
	end
	local constants = debug.getconstants(testf)
	assert(constants[1] == 50000, "First constant must be 50000")
	assert(constants[2] == "print", "Second constant must be print")
	assert(constants[3] == nil, "Third constant must be nil")
	assert(constants[4] == "Hello, world!", "Fourth constant must be 'Hello, world!'")
	assert(constants[5] == "warn", "Fifth constant must be warn")
end)

test("debug.getinfo", {}, function()
	local types = {
		source = "string",
		short_src = "string",
		func = "function",
		what = "string",
		currentline = "number",
		name = "string",
		nups = "number",
		numparams = "number",
		is_vararg = "number",
	}
	local function testf(...)
		print(...)
	end
	local info = debug.getinfo(testf)
	for k, v in pairs(types) do
		assert(info[k] ~= nil, "Did not return a table with a '" .. k .. "' field")
		assert(type(info[k]) == v, "Did not return a table with " .. k .. " as a " .. v .. " (got " .. type(info[k]) .. ")")
	end
end)

test("debug.getproto", {}, function()
	local function testf()
		local function proto()
			return true
		end
	end
	local proto = debug.getproto(testf, 1, true)[1]
	local realproto = debug.getproto(testf, 1)
	assert(proto, "Failed to get the inner function")
	assert(proto() == true, "The inner function did not return anything")
	if not realproto() then
		return "Proto return values are disabled on this executor"
	end
end)

test("debug.getprotos", {}, function()
	local function testf()
		local function _1()
			return true
		end
		local function _2()
			return true
		end
		local function _3()
			return true
		end
	end
	for i in ipairs(debug.getprotos(testf)) do
		local proto = debug.getproto(testf, i, true)[1]
		local realproto = debug.getproto(testf, i)
		assert(proto(), "Failed to get inner function " .. i)
		if not realproto() then
			return "Proto return values are disabled on this executor"
		end
	end
end)

test("debug.getstack", {}, function()
	local _ = "a" .. "b"
	assert(debug.getstack(1, 1) == "ab", "The first item in the stack should be 'ab'")
	assert(debug.getstack(1)[1] == "ab", "The first item in the stack table should be 'ab'")
end)

test("debug.getupvalue", {}, function()
	local upvalue = function() end
	local function testf()
		print(upvalue)
	end
	assert(debug.getupvalue(testf, 1) == upvalue, "Unexpected value returned from debug.getupvalue")
end)

test("debug.getupvalues", {}, function()
	local upvalue = function() end
	local function testf()
		print(upvalue)
	end
	local upvalues = debug.getupvalues(testf)
	assert(upvalues[1] == upvalue, "Unexpected value returned from debug.getupvalues")
end)

test("debug.setconstant", {}, function()
	local function testf()
		return "fail"
	end
	debug.setconstant(testf, 1, "success")
	assert(testf() == "success", "debug.setconstant did not set the first constant")
end)

test("debug.setstack", {}, function()
	local function testf()
		return "fail", debug.setstack(1, 1, "success")
	end
	assert(testf() == "success", "debug.setstack did not set the first stack item")
end)

test("debug.setupvalue", {}, function()
	local function upvalue()
		return "fail"
	end
	local function testf()
		return upvalue()
	end
	debug.setupvalue(testf, 1, function()
		return "success"
	end)
	assert(testf() == "success", "debug.setupvalue did not set the first upvalue")
end)

test("delfile", {}, function()
	writefile(".tests/delfile.txt", "Hello, world!")
	delfile(".tests/delfile.txt")
	assert(isfile(".tests/delfile.txt") == false, "Failed to delete file (isfile = " .. tostring(isfile(".tests/delfile.txt")) .. ")")
end)

test("delfolder", {}, function()
	makefolder(".tests/delfolder")
	delfolder(".tests/delfolder")
	assert(isfolder(".tests/delfolder") == false, "Failed to delete folder (isfolder = " .. tostring(isfolder(".tests/delfolder")) .. ")")
end)

test("dofile", {}, function()
	writefile(".tests/dofile.lua", "local v = 0 for i = 1, 2 do v = v + 1 end return v")
	local r1 = dofile(".tests/dofile.lua")
	assert(r1 == 2, "dofile did not return expected result")

	writefile(".tests/dofile_bad.lua", "f")
	local ok, err = pcall(dofile, ".tests/dofile_bad.lua")
	assert(not ok and type(err) == "string", "dofile did not raise a compile error on invalid file")
end)

test("Drawing", {})

test("Drawing.Fonts", {}, function()
	assert(Drawing.Fonts.UI == 0, "Did not return the correct id for UI")
	assert(Drawing.Fonts.System == 1, "Did not return the correct id for System")
	assert(Drawing.Fonts.Plex == 2, "Did not return the correct id for Plex")
	assert(Drawing.Fonts.Monospace == 3, "Did not return the correct id for Monospace")
end)

test("Drawing.new", {}, function()
	local drawing = Drawing.new("Square")
	drawing.Visible = false
	local canDestroy = pcall(function()
		drawing:Destroy()
	end)
	assert(canDestroy, "Drawing:Destroy() should not throw an error")
end)

test("getcallbackvalue", {}, function()
	local bindable = Instance.new("BindableFunction")
	local function testf()
	end
	bindable.OnInvoke = testf
	assert(getcallbackvalue(bindable, "OnInvoke") == testf, "Did not return the correct value")
end)

test("getclipboard", {}, function()
	local v = getclipboard()
	assert(v == nil or type(v) == "string", "getclipboard must return a string or nil")
end)

test("getconnections", {}, function()
	local types = {
		Enabled = "boolean",
		ForeignState = "boolean",
		LuaConnection = "boolean",
		Function = "function",
		Thread = "thread",
		Fire = "function",
		Defer = "function",
		Disconnect = "function",
		Disable = "function",
		Enable = "function",
	}
	local bindable = Instance.new("BindableEvent")
	bindable.Event:Connect(function() end)
	local connection = getconnections(bindable.Event)[1]
	for k, v in pairs(types) do
		assert(connection[k] ~= nil, "Did not return a table with a '" .. k .. "' field")
		assert(type(connection[k]) == v, "Did not return a table with " .. k .. " as a " .. v .. " (got " .. type(connection[k]) .. ")")
	end
end)

test("getcustomasset", {}, function()
	writefile(".tests/getcustomasset.txt", "success")
	local contentId = getcustomasset(".tests/getcustomasset.txt")
	assert(type(contentId) == "string", "Did not return a string")
	assert(#contentId > 0, "Returned an empty string")
	assert(string.match(contentId, "rbxasset://") == "rbxasset://", "Did not return an rbxasset url")
end)

test("getgc", {}, function()
	local gc = getgc()
	assert(type(gc) == "table", "Did not return a table")
	assert(#gc > 0, "Did not return a table with any values")
end)

test("getgenv", {}, function()
	getgenv().__TEST_GLOBAL = true
	assert(__TEST_GLOBAL, "Failed to set a global variable")
	getgenv().__TEST_GLOBAL = nil
end)

test("gethiddenproperty", {}, function()
	local fire = Instance.new("Fire")
	local property, isHidden = gethiddenproperty(fire, "size_xml")
	assert(property == 5, "Did not return the correct value")
	assert(isHidden == true, "Did not return whether the property was hidden")
end)

test("gethui", {}, function()
	assert(typeof(gethui()) == "Instance", "Did not return an Instance")
end)

test("getinstances", {}, function()
	assert(getinstances()[1]:IsA("Instance"), "The first value is not an Instance")
end)

test("getloadedmodules", {}, function()
	local modules = getloadedmodules()
	assert(type(modules) == "table", "Did not return a table")
	assert(#modules > 0, "Did not return a table with any values")
	assert(typeof(modules[1]) == "Instance", "First value is not an Instance")
	assert(modules[1]:IsA("ModuleScript"), "First value is not a ModuleScript")
end)

test("getnamecallmethod", {}, function()
	local method
	local ref
	ref = hookmetamethod(game, "__namecall", function(...)
		if not method then
			method = getnamecallmethod()
		end
		return ref(...)
	end)
	game:GetService("Lighting")
	assert(method == "GetService", "Did not get the correct method (GetService)")
end)

test("getnilinstances", {}, function()
	assert(getnilinstances()[1]:IsA("Instance"), "The first value is not an Instance")
	assert(getnilinstances()[1].Parent == nil, "The first value is not parented to nil")
end)

test("getrawmetatable", {}, function()
	local metatable = {__metatable = "Locked!"}
	local object = setmetatable({}, metatable)
	assert(getrawmetatable(object) == metatable, "Did not return the metatable")
end)

test("getrenv", {}, function()
	assert(_G ~= getrenv()._G, "The variable _G in the executor is identical to _G in the game")
end)

test("getrunningscripts", {}, function()
	local scripts = getrunningscripts()
	assert(type(scripts) == "table", "Did not return a table")
	assert(#scripts > 0, "Did not return a table with any values")
	assert(typeof(scripts[1]) == "Instance", "First value is not an Instance")
	assert(scripts[1]:IsA("ModuleScript") or scripts[1]:IsA("LocalScript"), "First value is not a ModuleScript or LocalScript")
end)

test("getscriptbytecode", {"dumpstring"}, function()
	local animate = game:GetService("Players").LocalPlayer.Character.Animate
	local bytecode = getscriptbytecode(animate)
	assert(type(bytecode) == "string", "Did not return a string for Character.Animate (a " .. animate.ClassName .. ")")
end)

test("getscripthash", {}, function()
	local animate = game:GetService("Players").LocalPlayer.Character.Animate:Clone()
	local hash = getscripthash(animate)
	local source = animate.Source
	animate.Source = "print('Hello, world!')"
	task.defer(function()
		animate.Source = source
	end)
	local newHash = getscripthash(animate)
	assert(hash ~= newHash, "Did not return a different hash for a modified script")
	assert(newHash == getscripthash(animate), "Did not return the same hash for a script with the same source")
end)

test("getscripts", {}, function()
	local scripts = getscripts()
	assert(type(scripts) == "table", "Did not return a table")
	assert(#scripts > 0, "Did not return a table with any values")
	assert(typeof(scripts[1]) == "Instance", "First value is not an Instance")
	assert(scripts[1]:IsA("ModuleScript") or scripts[1]:IsA("LocalScript"), "First value is not a ModuleScript or LocalScript")
end)

test("getsenv", {}, function()
	local animate = game:GetService("Players").LocalPlayer.Character.Animate
	local env = getsenv(animate)
	assert(type(env) == "table", "Did not return a table for Character.Animate (a " .. animate.ClassName .. ")")
	assert(env.script == animate, "The script global is not identical to Character.Animate")
end)

test("getstack", {}, function()
	local _ = "a" .. "b"
	assert(debug.getstack(1, 1) == "ab", "The first item in the stack should be 'ab'")
	assert(debug.getstack(1)[1] == "ab", "The first item in the stack table should be 'ab'")
end)

test("getthreadidentity", {"getidentity", "getthreadcontext"}, function()
	assert(type(getthreadidentity()) == "number", "Did not return a number")
end)

test("identifyexecutor", {"getexecutorname"}, function()
	local name, version = identifyexecutor()
	assert(type(name) == "string", "Did not return a string for the name")
	return type(version) == "string" and "Returns version as a string" or "Does not return version"
end)

test("isfile", {}, function()
	writefile(".tests/isfile.txt", "success")
	assert(isfile(".tests/isfile.txt") == true, "Did not return true for a file")
	assert(isfile(".tests") == false, "Did not return false for a folder")
	assert(isfile(".tests/doesnotexist.exe") == false, "Did not return false for a nonexistent path (got " .. tostring(isfile(".tests/doesnotexist.exe")) .. ")")
end)

test("isfolder", {}, function()
	assert(isfolder(".tests") == true, "Did not return false for a folder")
	assert(isfolder(".tests/doesnotexist.exe") == false, "Did not return false for a nonexistent path (got " .. tostring(isfolder(".tests/doesnotexist.exe")) .. ")")
end)

test("isrbxactive", {"isgameactive"}, function()
	assert(type(isrbxactive()) == "boolean", "Did not return a boolean value")
end)

test("isreadonly", {}, function()
	local object = {}
	table.freeze(object)
	assert(isreadonly(object), "Did not return true for a read-only table")
end)

test("isrenderobj", {}, function()
	local drawing = Drawing.new("Image")
	drawing.Visible = true
	assert(isrenderobj(drawing) == true, "Did not return true for an Image")
	assert(isrenderobj(newproxy()) == false, "Did not return false for a blank table")
end)

test("iscclosure", {}, function()
	assert(iscclosure(print) == true, "Function 'print' should be a C closure")
	assert(iscclosure(function() end) == false, "Executor function should not be a C closure")
end)

test("isexecutorclosure", {"checkclosure", "isourclosure"}, function()
	assert(isexecutorclosure(isexecutorclosure) == true, "Did not return true for an executor global")
	assert(isexecutorclosure(newcclosure(function() end)) == true, "Did not return true for an executor C closure")
	assert(isexecutorclosure(function() end) == true, "Did not return true for an executor Luau closure")
	assert(isexecutorclosure(print) == false, "Did not return false for a Roblox global")
end)

test("islclosure", {}, function()
	assert(islclosure(print) == false, "Function 'print' should not be a Lua closure")
	assert(islclosure(function() end) == true, "Executor function should be a Lua closure")
end)

test("isscriptable", {}, function()
	local fire = Instance.new("Fire")
	assert(isscriptable(fire, "size_xml") == false, "Did not return false for a non-scriptable property (size_xml)")
	assert(isscriptable(fire, "Size") == true, "Did not return true for a scriptable property (Size)")
end)

test("listfiles", {}, function()
	makefolder(".tests/listfiles")
	writefile(".tests/listfiles/test_1.txt", "success")
	writefile(".tests/listfiles/test_2.txt", "success")
	local files = listfiles(".tests/listfiles")
	assert(#files == 2, "Did not return the correct number of files")
	assert(isfile(files[1]), "Did not return a file path")
	assert(readfile(files[1]) == "success", "Did not return the correct files")
	makefolder(".tests/listfiles_2")
	makefolder(".tests/listfiles_2/test_1")
	makefolder(".tests/listfiles_2/test_2")
	local folders = listfiles(".tests/listfiles_2")
	assert(#folders == 2, "Did not return the correct number of folders")
	assert(isfolder(folders[1]), "Did not return a folder path")
end)

test("loadfile", {}, function()
	writefile(".tests/loadfile.txt", "return ... + 1")
	assert(assert(loadfile(".tests/loadfile.txt"))(1) == 2, "Failed to load a file with arguments")
	writefile(".tests/loadfile.txt", "f")
	local callbackf, err = loadfile(".tests/loadfile.txt")
	assert(err and not callbackf, "Did not return an error message for a compiler error")
end)

test("loadstring", {}, function()
	local animate = game:GetService("Players").LocalPlayer.Character.Animate
	local bytecode = getscriptbytecode(animate)
	local func = loadstring(bytecode)
	assert(type(func) ~= "function", "Luau bytecode should not be loadable")
	assert(assert(loadstring("return ... + 1"))(1) == 2, "Failed to do simple math")
	assert(type(select(2, loadstring("f"))) == "string", "Loadstring did not return anything for a compiler error")
end)

test("lz4compress", {}, function()
	local raw = "Hello, world!"
	local compressed = lz4compress(raw)
	assert(type(compressed) == "string", "Compression did not return a string")
	assert(lz4decompress(compressed, #raw) == raw, "Decompression did not return the original string")
end)

test("lz4decompress", {}, function()
	local raw = "Hello, world!"
	local compressed = lz4compress(raw)
	assert(type(compressed) == "string", "Compression did not return a string")
	assert(lz4decompress(compressed, #raw) == raw, "Decompression did not return the original string")
end)

test("makefolder", {}, function()
	makefolder(".tests/makefolder")
	assert(isfolder(".tests/makefolder"), "Did not create the folder")
end)

test("messagebox", {}, function()
	print("UNC: A messagebox will appear. Click 'OK' to continue the UNC test.")
	local ok, res = pcall(messagebox, "UNC_TEST_MESSAGEBOX", "UNC UNC_TEST", 0)
	assert(ok, res or "messagebox errored")
	local t = type(res)
	assert(t == "number" or t == "nil", "messagebox must return button id (number) or nil")
end)

test("mouse1click", {}, function()
	local ok1, err1 = pcall(mouse1click)
	local ok2, err2 = pcall(mouse1click)
	assert(ok1 and ok2, err1 or err2 or "mouse1click errored")
end)

test("mouse1press", {}, function()
	local ok1, err1 = pcall(mouse1press)
	local ok2, err2 = pcall(mouse1release)
	assert(ok1 and ok2, err1 or err2 or "mouse1press/mouse1release errored")
end)

test("mouse1release", {}, function()
	local ok, err = pcall(mouse1release)
	assert(ok, err or "mouse1release errored")
end)

test("mouse2click", {}, function()
	local ok1, err1 = pcall(mouse2click)
	local ok2, err2 = pcall(mouse2click)
	assert(ok1 and ok2, err1 or err2 or "mouse2click errored")
end)

test("mouse2press", {}, function()
	local ok1, err1 = pcall(mouse2press)
	local ok2, err2 = pcall(mouse2release)
	assert(ok1 and ok2, err1 or err2 or "mouse2press/mouse2release errored")
end)

test("mouse2release", {}, function()
	local ok, err = pcall(mouse2release)
	assert(ok, err or "mouse2release errored")
end)

test("mousemoveabs", {}, function()
	local ok1, err1 = pcall(mousemoveabs, 0, 0)
	local ok2, err2 = pcall(mousemoveabs, 100, 100)
	assert(ok1 and ok2, err1 or err2 or "mousemoveabs errored")
end)

test("mousemoverel", {}, function()
	local ok1, err1 = pcall(mousemoverel, 0, 0)
	local ok2, err2 = pcall(mousemoverel, 10, -10)
	assert(ok1 and ok2, err1 or err2 or "mousemoverel errored")
end)

test("mousescroll", {}, function()
	local ok1, err1 = pcall(mousescroll, 1)
	local ok2, err2 = pcall(mousescroll, -1)
	assert(ok1 and ok2, err1 or err2 or "mousescroll errored")
end)

test("newcclosure", {}, function()
	local function testf()
		return true
	end
	local testC = newcclosure(testf)
	assert(testf() == testC(), "New C closure should return the same value as the original")
	assert(testf ~= testC, "New C closure should not be same as the original")
	assert(iscclosure(testC), "New C closure should be a C closure")
end)

test("queue_on_teleport", {"queueonteleport"}, function()
	local ok, err = pcall(queue_on_teleport, "return 1")
	assert(ok, err or "queue_on_teleport errored")
end)

test("rconsoleclear", {"consoleclear"}, nil, true)
test("rconsolecreate", {"consolecreate"}, nil, true)
test("rconsoledestroy", {"consoledestroy"}, nil, true)
test("rconsoleinput", {"consoleinput"}, nil, true)
test("rconsoleprint", {"consoleprint"}, nil, true)
test("rconsolesettitle", {"rconsolename", "consolesettitle"}, nil, true)

test("readfile", {}, function()
	writefile(".tests/readfile.txt", "success")
	assert(readfile(".tests/readfile.txt") == "success", "Did not return the contents of the file")
end)

test("request", {"http.request", "http_request"}, function()
	local response = request({
		Url = "https://httpbin.org/user-agent",
		Method = "GET",
	})
	assert(type(response) == "table", "Response must be a table")
	assert(response.StatusCode == 200, "Did not return a 200 status code")
	local data = game:GetService("HttpService"):JSONDecode(response.Body)
	assert(type(data) == "table" and type(data["user-agent"]) == "string", "Did not return a table with a user-agent key")
	return "User-Agent: " .. data["user-agent"]
end)

test("setclipboard", {"toclipboard"}, function()
	local ok, err = pcall(setclipboard, "UNC_TEST_CLIPBOARD")
	assert(ok, err or "setclipboard errored")
end)

test("setfpscap", {}, function()
	local rs = game:GetService("RunService").RenderStepped

	local function measure()
		rs:Wait()
		local sum = 0
		local n = 10
		for i = 1, n do
			sum += 1 / rs:Wait()
		end
		return math.round(sum / n)
	end

	setfpscap(60)
	local fps60 = measure()

	setfpscap(240)
	local fps240 = measure()

	setfpscap(0)
	local fps0 = measure()

	assert(fps60 > 0 and fps240 > 0 and fps0 > 0, "FPS samples invalid")

	local uncappedHigher = fps0 > fps240
	local msg = "60=" .. fps60 .. "fps, 240=" .. fps240 .. "fps, uncapped=" .. fps0 .. "fps"

	if fps0 > 240 then
		msg = msg .. " • uncapped > 240"
	elseif uncappedHigher then
		msg = msg .. " • uncapped > 240 cap not confirmed (but higher than 240 cap)"
	else
		msg = msg .. " • environment appears capped (vsync or executor limitation)"
	end

	return msg
end)

test("sethiddenproperty", {}, function()
	local fire = Instance.new("Fire")
	local hidden = sethiddenproperty(fire, "size_xml", 10)
	assert(hidden, "Did not return true for the hidden property")
	assert(gethiddenproperty(fire, "size_xml") == 10, "Did not set the hidden property")
end)

test("setrbxclipboard", {}, function()
	local ok, err = pcall(setrbxclipboard, "UNC_TEST_RBXCLIP")
	assert(ok, err or "setrbxclipboard errored")
end)

test("setrawmetatable", {}, function()
	local object = setmetatable({}, {__index = function() return false end, __metatable = "Locked!"})
	local objectReturned = setrawmetatable(object, {__index = function() return true end})
	assert(object, "Did not return the original object")
	assert(object.test == true, "Failed to change the metatable")
	if objectReturned then
		return objectReturned == object and "Returned the original object" or "Did not return the original object"
	end
end)

test("setreadonly", {}, function()
	local object = {success = false}
	table.freeze(object)
	setreadonly(object, false)
	object.success = true
	assert(object.success, "Did not allow the table to be modified")
end)

test("setscriptable", {}, function()
	local fire = Instance.new("Fire")
	local wasScriptable = setscriptable(fire, "size_xml", true)
	assert(wasScriptable == false, "Did not return false for a non-scriptable property (size_xml)")
	assert(isscriptable(fire, "size_xml") == true, "Did not set the scriptable property")
	fire = Instance.new("Fire")
	assert(isscriptable(fire, "size_xml") == false, "⚠️⚠️ setscriptable persists between unique instances ⚠️⚠️")
end)

test("setthreadidentity", {"setidentity", "setthreadcontext"}, function()
	setthreadidentity(3)
	assert(getthreadidentity() == 3, "Did not set the thread identity")
end)

test("WebSocket", {})

test("WebSocket.connect", {}, function()
	local types = {
		Send = "function",
		Close = "function",
		OnMessage = {"table", "userdata"},
		OnClose = {"table", "userdata"},
	}
	local ws = WebSocket.connect("ws://echo.websocket.events")
	assert(type(ws) == "table" or type(ws) == "userdata", "Did not return a table or userdata")
	for k, v in pairs(types) do
		if type(v) == "table" then
			assert(table.find(v, type(ws[k])), "Did not return a " .. table.concat(v, ", ") .. " for " .. k .. " (a " .. type(ws[k]) .. ")")
		else
			assert(type(ws[k]) == v, "Did not return a " .. v .. " for " .. k .. " (a " .. type(ws[k]) .. ")")
		end
	end
	ws:Close()
end)

local function runRcon()
	local lp, lf = 0, 0

	local function dropExist(n)
		for i, v in ipairs(list_exists_only) do
			if v == n then
				table.remove(list_exists_only, i)
				existsOnly -= 1
				break
			end
		end
	end

	local defs = {
		{
			n = "rconsolecreate",
			a = {"consolecreate"},
			f = function(fn)
				local ok, err = pcall(fn, "UNC_TEST")
				assert(ok, err or "rconsolecreate errored")
			end,
		},
		{
			n = "rconsolesettitle",
			a = {"rconsolename", "consolesettitle"},
			f = function(fn)
				local ok, err = pcall(fn, "UNC_UNC")
				assert(ok, err or "rconsolesettitle errored")
			end,
		},
		{
			n = "rconsoleprint",
			a = {"consoleprint"},
			f = function(fn)
				local ok, err = pcall(fn, "UNC rconsoleprint test\n")
				assert(ok, err or "rconsoleprint errored")
			end,
		},
		{
			n = "rconsoleclear",
			a = {"consoleclear"},
			f = function(fn)
				local ok, err = pcall(fn)
				assert(ok, err or "rconsoleclear errored")
			end,
		},
		{
			n = "rconsoledestroy",
			a = {"consoledestroy"},
			f = function(fn)
				local ok, err = pcall(fn)
				assert(ok, err or "rconsoledestroy errored")
			end,
		},
	}

	print("UNC rconsole tests: starting")

	for _, d in ipairs(defs) do
		local fn
		local names = {d.n}
		for _, al in ipairs(d.a) do
			table.insert(names, al)
		end
		for _, nm in ipairs(names) do
			local g = getGlobal(nm)
			if type(g) == "function" then
				fn = g
				break
			end
		end

		if fn then
			dropExist(d.n)
			local ok, msg = pcall(d.f, fn)
			if ok then
				lp += 1
				passes += 1
				table.insert(list_pass, d.n)
				print("✅ [rconsole] " .. d.n)
			else
				lf += 1
				fails += 1
				local e = d.n .. " • " .. tostring(msg)
				table.insert(list_fail, e)
				warn("⛔ [rconsole] " .. e)
			end
		end
	end

	print("UNC rconsole tests: " .. lp .. " passes, " .. lf .. " fails")

	local testedTotal = passes + fails
	local rate = testedTotal > 0 and math.round(passes / testedTotal * 100) or 0
	local outOf = passes .. " out of " .. testedTotal

	print("\nUNC Summary (after rconsole)")
	print("✅ Passes: " .. passes)
	print("⛔ Fails: " .. fails)
	print("⏺️ Exists but untested: " .. existsOnly)
	print("❌ Missing required globals: " .. missing)
	print("⏺️ Missing optional globals: " .. optionalMissing)
	print("⚠️ Globals with missing aliases: " .. undefined)
	print("Tested success rate: " .. rate .. "% (" .. outOf .. ")\n")

	local verdict
	if testedTotal == 0 then
		verdict = "No UNC functions were actually tested. Almost everything is missing."
	elseif rate >= 90 and fails == 0 and missing == 0 then
		verdict = "Excellent UNC compatibility: almost everything matches and behaves correctly."
	elseif rate >= 80 and fails == 0 then
		verdict = "Very good UNC compatibility: core features behave correctly, some globals or aliases missing."
	elseif rate >= 60 then
		verdict = "Decent UNC compatibility: usable, but several functions are missing or behave differently."
	elseif rate >= 30 then
		verdict = "Poor UNC compatibility: many UNC features fail or are missing."
	else
		verdict = "Very bad UNC compatibility: this environment barely matches UNC."
	end

	print("Verdict: " .. verdict .. "\n")
end

local function promptRcon()
	local has =
		getGlobal("rconsoleclear")
		or getGlobal("rconsolecreate")
		or getGlobal("rconsoleprint")
		or getGlobal("rconsolesettitle")
		or getGlobal("consoleclear")
		or getGlobal("consolecreate")
		or getGlobal("consoleprint")
		or getGlobal("consolesettitle")

	if not has then
		return
	end

	local sg = game:GetService("StarterGui")
	local bf = Instance.new("BindableFunction")
	bf.OnInvoke = function(ans)
		if ans == "Sure" then
			runRcon()
		end
	end

	pcall(function()
		sg:SetCore("SendNotification", {
			Title = "UNC rconsole tests",
			Text = "Some executors can crash when rconsole is used.\nRun extra rconsole tests?",
			Duration = 15,
			Button1 = "Sure",
			Button2 = "Nah",
			Callback = bf,
		})
	end)
end

promptRcon()