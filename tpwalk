local function SafeGetService(name)
	local GetService = game.GetService;
	local Ref = cloneref or function(x)
		return x;
	end;
	return Ref(GetService(game, name));
end;
local Players = SafeGetService("Players");
local RunService = SafeGetService("RunService");
local TweenService = SafeGetService("TweenService");
local UserInputService = SafeGetService("UserInputService");
local CoreGui = SafeGetService("CoreGui");
local player = Players.LocalPlayer;
local function protectUI(gui)
	if gui:IsA("ScreenGui") then
		gui.ZIndexBehavior = Enum.ZIndexBehavior.Global;
		gui.DisplayOrder = 2147483647;
		gui.ResetOnSpawn = false;
		gui.IgnoreGuiInset = true;
	end;
	local target;
	if gethui then
		target = gethui();
	elseif CoreGui and CoreGui:FindFirstChild("RobloxGui") then
		target = CoreGui:FindFirstChild("RobloxGui");
	elseif CoreGui then
		target = CoreGui;
	elseif player then
		target = player:FindFirstChildOfClass("PlayerGui");
	end;
	if not target then
		return nil;
	end;
	gui.Name = "\000";
	gui.Archivable = false;
	gui.Parent = target;
	return gui;
end;
local function t(i, time, style, dir, props)
	(TweenService:Create(i, TweenInfo.new(time, style or Enum.EasingStyle.Quad, dir or Enum.EasingDirection.Out), props)):Play();
end;
local screenGui = Instance.new("ScreenGui");
if not protectUI(screenGui) then
	return;
end;
local root = Instance.new("Frame");
root.Size = UDim2.fromOffset(260, 140);
root.Position = UDim2.new(0.5, 0, 0, 16);
root.AnchorPoint = Vector2.new(0.5, 0);
root.BackgroundTransparency = 0.1;
root.BackgroundColor3 = Color3.fromRGB(18, 18, 20);
root.ClipsDescendants = false;
root.Parent = screenGui;
local corner = Instance.new("UICorner");
corner.CornerRadius = UDim.new(0, 10);
corner.Parent = root;
local stroke = Instance.new("UIStroke");
stroke.Thickness = 1;
stroke.Color = Color3.fromRGB(255, 255, 255);
stroke.Transparency = 0.75;
stroke.Parent = root;
local gradient = Instance.new("UIGradient");
gradient.Color = ColorSequence.new({
	ColorSequenceKeypoint.new(0, Color3.fromRGB(50, 90, 255)),
	ColorSequenceKeypoint.new(1, Color3.fromRGB(170, 60, 255))
});
gradient.Rotation = 35;
gradient.Transparency = NumberSequence.new({
	NumberSequenceKeypoint.new(0, 0.1),
	NumberSequenceKeypoint.new(1, 0.1)
});
gradient.Parent = root;
local inner = Instance.new("Frame");
inner.BackgroundTransparency = 0.15;
inner.BackgroundColor3 = Color3.fromRGB(10, 10, 12);
inner.Size = UDim2.fromScale(1, 1);
inner.ClipsDescendants = false;
inner.Parent = root;
local innerCorner = Instance.new("UICorner");
innerCorner.CornerRadius = UDim.new(0, 10);
innerCorner.Parent = inner;
local padding = Instance.new("UIPadding");
padding.PaddingTop = UDim.new(0, 10);
padding.PaddingBottom = UDim.new(0, 10);
padding.PaddingLeft = UDim.new(0, 12);
padding.PaddingRight = UDim.new(0, 12);
padding.Parent = inner;
local list = Instance.new("UIListLayout");
list.FillDirection = Enum.FillDirection.Vertical;
list.HorizontalAlignment = Enum.HorizontalAlignment.Left;
list.SortOrder = Enum.SortOrder.LayoutOrder;
list.Padding = UDim.new(0, 10);
list.Parent = inner;
local header = Instance.new("Frame");
header.Size = UDim2.new(1, 0, 0, 28);
header.BackgroundTransparency = 1;
header.LayoutOrder = 1;
header.Parent = inner;
local title = Instance.new("TextLabel");
title.Size = UDim2.new(1, -32, 1, 0);
title.BackgroundTransparency = 1;
title.Text = "TPWalk";
title.TextXAlignment = Enum.TextXAlignment.Left;
title.Font = Enum.Font.GothamSemibold;
title.TextSize = 18;
title.TextColor3 = Color3.fromRGB(230, 230, 235);
title.Parent = header;
local mini = Instance.new("TextButton");
mini.Size = UDim2.fromOffset(24, 24);
mini.AnchorPoint = Vector2.new(1, 0.5);
mini.Position = UDim2.new(1, 0, 0.5, 0);
mini.BackgroundTransparency = 1;
mini.Text = "â€”";
mini.TextScaled = true;
mini.Font = Enum.Font.GothamSemibold;
mini.TextColor3 = Color3.fromRGB(200, 200, 210);
mini.Parent = header;
local rowToggle = Instance.new("Frame");
rowToggle.Size = UDim2.new(1, 0, 0, 36);
rowToggle.BackgroundTransparency = 1;
rowToggle.LayoutOrder = 2;
rowToggle.Parent = inner;
local lblToggle = Instance.new("TextLabel");
lblToggle.Size = UDim2.new(1, -70, 1, 0);
lblToggle.BackgroundTransparency = 1;
lblToggle.Text = "Enabled";
lblToggle.TextXAlignment = Enum.TextXAlignment.Left;
lblToggle.Font = Enum.Font.Gotham;
lblToggle.TextSize = 16;
lblToggle.TextColor3 = Color3.fromRGB(210, 210, 220);
lblToggle.Parent = rowToggle;
local toggleBtn = Instance.new("TextButton");
toggleBtn.Size = UDim2.fromOffset(64, 30);
toggleBtn.Position = UDim2.new(1, 0, 0.5, 0);
toggleBtn.AnchorPoint = Vector2.new(1, 0.5);
toggleBtn.AutoButtonColor = false;
toggleBtn.Text = "";
toggleBtn.BackgroundColor3 = Color3.fromRGB(70, 75, 85);
toggleBtn.Parent = rowToggle;
local toggleCorner = Instance.new("UICorner");
toggleCorner.CornerRadius = UDim.new(0, 15);
toggleCorner.Parent = toggleBtn;
local knob = Instance.new("Frame");
knob.Size = UDim2.fromOffset(26, 26);
knob.Position = UDim2.new(0, 2, 0.5, 0);
knob.AnchorPoint = Vector2.new(0, 0.5);
knob.BackgroundColor3 = Color3.fromRGB(240, 240, 245);
knob.Parent = toggleBtn;
local knobCorner = Instance.new("UICorner");
knobCorner.CornerRadius = UDim.new(1, 0);
knobCorner.Parent = knob;
local knobStroke = Instance.new("UIStroke");
knobStroke.Thickness = 1;
knobStroke.Transparency = 0.5;
knobStroke.Color = Color3.fromRGB(0, 0, 0);
knobStroke.Parent = knob;
local rowSpeed = Instance.new("Frame");
rowSpeed.Size = UDim2.new(1, 0, 0, 56);
rowSpeed.BackgroundTransparency = 1;
rowSpeed.LayoutOrder = 3;
rowSpeed.Parent = inner;
local lblSpeed = Instance.new("TextLabel");
lblSpeed.Size = UDim2.new(0, 54, 1, 0);
lblSpeed.BackgroundTransparency = 1;
lblSpeed.Text = "Speed";
lblSpeed.TextXAlignment = Enum.TextXAlignment.Left;
lblSpeed.Font = Enum.Font.Gotham;
lblSpeed.TextSize = 16;
lblSpeed.TextColor3 = Color3.fromRGB(210, 210, 220);
lblSpeed.Parent = rowSpeed;
local slider = Instance.new("Frame");
slider.Size = UDim2.new(1, -90, 0, 8);
slider.Position = UDim2.new(0, 60, 0.5, 0);
slider.AnchorPoint = Vector2.new(0, 0.5);
slider.BackgroundColor3 = Color3.fromRGB(60, 60, 70);
slider.Parent = rowSpeed;
local sliderCorner = Instance.new("UICorner");
sliderCorner.CornerRadius = UDim.new(0, 4);
sliderCorner.Parent = slider;
local fill = Instance.new("Frame");
fill.Size = UDim2.new(0, 0, 1, 0);
fill.BackgroundColor3 = Color3.fromRGB(120, 130, 255);
fill.Parent = slider;
local fillCorner = Instance.new("UICorner");
fillCorner.CornerRadius = UDim.new(0, 4);
fillCorner.Parent = fill;
local handle = Instance.new("Frame");
handle.Size = UDim2.fromOffset(18, 18);
handle.Position = UDim2.new(0, 0, 0.5, 0);
handle.AnchorPoint = Vector2.new(0.5, 0.5);
handle.BackgroundColor3 = Color3.fromRGB(230, 230, 240);
handle.Parent = slider;
local handleCorner = Instance.new("UICorner");
handleCorner.CornerRadius = UDim.new(1, 0);
handleCorner.Parent = handle;
local speedValue = Instance.new("TextLabel");
speedValue.Size = UDim2.fromOffset(64, 24);
speedValue.AnchorPoint = Vector2.new(1, 0.5);
speedValue.Position = UDim2.new(1, 0, 0.5, 0);
speedValue.BackgroundTransparency = 1;
speedValue.TextXAlignment = Enum.TextXAlignment.Right;
speedValue.Font = Enum.Font.GothamSemibold;
speedValue.TextSize = 14;
speedValue.TextColor3 = Color3.fromRGB(235, 235, 240);
speedValue.Parent = rowSpeed;
local active = false;
local collapsed = false;
local draggingHeader = false;
local dragInput;
local dragStart;
local startPos;
local draggingSlider = false;
local minSpeed, maxSpeed = 0, 50;
local speed = 1;
local function setToggle(on)
	active = on;
	if on then
		t(toggleBtn, 0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
			BackgroundColor3 = Color3.fromRGB(95, 120, 255)
		});
		t(knob, 0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
			Position = UDim2.new(1, -28, 0.5, 0)
		});
		t(knob, 0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
			Size = UDim2.fromOffset(28, 28)
		});
		task.delay(0.12, function()
			t(knob, 0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
				Size = UDim2.fromOffset(26, 26)
			});
		end);
		t(stroke, 0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, {
			Transparency = 0.45
		});
	else
		t(toggleBtn, 0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
			BackgroundColor3 = Color3.fromRGB(70, 75, 85)
		});
		t(knob, 0.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
			Position = UDim2.new(0, 2, 0.5, 0)
		});
		t(stroke, 0.25, Enum.EasingStyle.Sine, Enum.EasingDirection.Out, {
			Transparency = 0.75
		});
	end;
end;
local function speedToPct(v)
	return (math.clamp(v, minSpeed, maxSpeed) - minSpeed) / (maxSpeed - minSpeed);
end;
local function pctToSpeed(p)
	return minSpeed + p * (maxSpeed - minSpeed);
end;
local function applySlider(v, animate)
	speed = math.floor((math.clamp(v, minSpeed, maxSpeed) * 10 + 0.5)) / 10;
	local p = speedToPct(speed);
	local x = slider.AbsoluteSize.X * p;
	speedValue.Text = tostring(speed);
	if animate then
		t(fill, 0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
			Size = UDim2.new(p, 0, 1, 0)
		});
		t(handle, 0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
			Position = UDim2.new(0, x, 0.5, 0)
		});
	else
		fill.Size = UDim2.new(p, 0, 1, 0);
		handle.Position = UDim2.new(0, x, 0.5, 0);
	end;
end;
local function setSliderFromInput(input)
	local xPos = input and input.Position and input.Position.X or (UserInputService:GetMouseLocation()).X;
	local left = slider.AbsolutePosition.X;
	local width = math.max(1, slider.AbsoluteSize.X);
	local p = math.clamp((xPos - left) / width, 0, 1);
	applySlider(pctToSpeed(p), true);
end;
toggleBtn.MouseEnter:Connect(function()
	t(knob, 0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
		Size = UDim2.fromOffset(28, 28)
	});
end);
toggleBtn.MouseLeave:Connect(function()
	t(knob, 0.12, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
		Size = UDim2.fromOffset(26, 26)
	});
end);
toggleBtn.MouseButton1Click:Connect(function()
	setToggle(not active);
end);
toggleBtn.TouchTap:Connect(function()
	setToggle(not active);
end);
slider.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		draggingSlider = true;
		setSliderFromInput(input);
		t(handle, 0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
			Size = UDim2.fromOffset(20, 20)
		});
	end;
end);
slider.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		draggingSlider = false;
		t(handle, 0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
			Size = UDim2.fromOffset(18, 18)
		});
	end;
end);
UserInputService.InputChanged:Connect(function(input)
	if draggingSlider and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
		setSliderFromInput(input);
	end;
end);
mini.MouseButton1Click:Connect(function()
	collapsed = not collapsed;
	local h = collapsed and 48 or 140;
	t(root, 0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
		Size = UDim2.fromOffset(root.AbsoluteSize.X, h)
	});
end);
mini.TouchTap:Connect(function()
	collapsed = not collapsed;
	local h = collapsed and 48 or 140;
	t(root, 0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
		Size = UDim2.fromOffset(root.AbsoluteSize.X, h)
	});
end);
local function clampToScreen(xOff, yOff, w, h)
	local s = screenGui.AbsoluteSize;
	local m = 6;
	local minX = (-s.X) / 2 + w / 2 + m;
	local maxX = s.X / 2 - w / 2 - m;
	local minY = m;
	local maxY = s.Y - h - m;
	return math.clamp(xOff, minX, maxX), math.clamp(yOff, minY, maxY);
end;
header.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		draggingHeader = true;
		dragStart = input.Position;
		startPos = root.Position;
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				draggingHeader = false;
			end;
		end);
	end;
end);
header.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		dragInput = input;
	end;
end);
UserInputService.InputChanged:Connect(function(input)
	if input == dragInput and draggingHeader then
		local delta = input.Position - dragStart;
		local x = startPos.X.Offset + delta.X;
		local y = startPos.Y.Offset + delta.Y;
		local w = root.AbsoluteSize.X;
		local h = root.AbsoluteSize.Y;
		local cx, cy = clampToScreen(x, y, w, h);
		root.Position = UDim2.new(0.5, cx, 0, cy);
	end;
end);
applySlider(1, false);
setToggle(false);
root.Visible = true;
root.Position = UDim2.new(0.5, 0, 0, -60);
t(root, 0.35, Enum.EasingStyle.Quart, Enum.EasingDirection.Out, {
	Position = UDim2.new(0.5, 0, 0, 16)
});
root.BackgroundTransparency = 1;
stroke.Transparency = 1;
title.TextTransparency = 1;
lblToggle.TextTransparency = 1;
lblSpeed.TextTransparency = 1;
speedValue.TextTransparency = 1;
t(root, 0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
	BackgroundTransparency = 0.1
});
t(stroke, 0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
	Transparency = 0.75
});
t(title, 0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
	TextTransparency = 0
});
t(lblToggle, 0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
	TextTransparency = 0
});
t(lblSpeed, 0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
	TextTransparency = 0
});
t(speedValue, 0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out, {
	TextTransparency = 0
});
RunService.Heartbeat:Connect(function(dt)
	if not active then
		return;
	end;
	local character = player and player.Character;
	if not character then
		return;
	end;
	local humanoid = character:FindFirstChildOfClass("Humanoid");
	if not humanoid then
		return;
	end;
	local dir = humanoid.MoveDirection;
	if dir.Magnitude > 0 then
		character:TranslateBy(dir * speed * (60 * dt));
	end;
end);
