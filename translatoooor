if not game['Loaded'] then game['Loaded']:Wait() end; repeat task.wait(.06) until game:GetService('Players').LocalPlayer ~= nil

local YourLang = "en"

if not isfile then function isfile(_) return false end end
if not readfile then function readfile(_) return "" end end
if not writefile then function writefile(_,_) end end

local HttpService = game:GetService("HttpService")
local function _request(opt)
	local fn = (syn and syn.request) or (http and http.request) or (http_request) or (request)
	if fn then return fn(opt) end
	return HttpService:RequestAsync(opt)
end

local googlev = isfile'googlev.txt' and readfile'googlev.txt' or ''

local function googleConsent(Body)
    local args = {}
    for match in Body:gmatch('<input type="hidden" name=".-" value=".-">') do
        local k,v = match:match('<input type="hidden" name="(.-)" value="(.-)">')
        args[k] = v
    end
    googlev = args.v or ""
    writefile('googlev.txt', googlev)
end

local function got(url, Method, Body)
    Method = Method or "GET"
    local res = _request({
        Url = url,
        Method = Method,
        Headers = {cookie="CONSENT=YES+"..(googlev or "")},
        Body = Body
    })
    local body = res.Body or res.body or ""
    if type(body) ~= "string" then body = tostring(body) end
    if body:match('https://consent.google.com/s') then
        googleConsent(body)
        res = _request({
            Url = url,
            Method = "GET",
            Headers = {cookie="CONSENT=YES+"..(googlev or "")}
        })
    end
    return res
end

local languages = {
    auto="Automatic",af="Afrikaans",sq="Albanian",am="Amharic",ar="Arabic",hy="Armenian",az="Azerbaijani",eu="Basque",be="Belarusian",bn="Bengali",bs="Bosnian",bg="Bulgarian",ca="Catalan",ceb="Cebuano",ny="Chichewa",
    ['zh-cn']="Chinese Simplified",['zh-tw']="Chinese Traditional",co="Corsican",hr="Croatian",cs="Czech",da="Danish",nl="Dutch",en="English",eo="Esperanto",et="Estonian",tl="Filipino",fi="Finnish",fr="French",fy="Frisian",
    gl="Galician",ka="Georgian",de="German",el="Greek",gu="Gujarati",ht="Haitian Creole",ha="Hausa",haw="Hawaiian",iw="Hebrew",hi="Hindi",hmn="Hmong",hu="Hungarian",is="Icelandic",ig="Igbo",id="Indonesian",ga="Irish",it="Italian",
    ja="Japanese",jw="Javanese",kn="Kannada",kk="Kazakh",km="Khmer",ko="Korean",ku="Kurdish (Kurmanji)",ky="Kyrgyz",lo="Lao",la="Latin",lv="Latvian",lt="Lithuanian",lb="Luxembourgish",mk="Macedonian",mg="Malagasy",ms="Malay",
    ml="Malayalam",mt="Maltese",mi="Maori",mr="Marathi",mn="Mongolian",my="Myanmar (Burmese)",ne="Nepali",no="Norwegian",ps="Pashto",fa="Persian",pl="Polish",pt="Portuguese",pa="Punjabi",ro="Romanian",ru="Russian",sm="Samoan",
    gd="Scots Gaelic",sr="Serbian",st="Sesotho",sn="Shona",sd="Sindhi",si="Sinhala",sk="Slovak",sl="Slovenian",so="Somali",es="Spanish",su="Sundanese",sw="Swahili",sv="Swedish",tg="Tajik",ta="Tamil",te="Telugu",th="Thai",tr="Turkish",
    uk="Ukrainian",ur="Urdu",uz="Uzbek",vi="Vietnamese",cy="Welsh",xh="Xhosa",yi="Yiddish",yo="Yoruba",zu="Zulu"
}

local function find(lang)
    for i,v in pairs(languages) do
        if i == lang or v == lang then
            return i
        end
    end
end

local function getISOCode(lang)
    return find(lang)
end

local function stringifyQuery(dataFields)
    local data = ""
    for k, v in pairs(dataFields) do
        if type(v) == "table" then
            for _,vv in pairs(v) do
                data ..= ("&%s=%s"):format(HttpService:UrlEncode(k), HttpService:UrlEncode(vv))
            end
        else
            data ..= ("&%s=%s"):format(HttpService:UrlEncode(k), HttpService:UrlEncode(v))
        end
    end
    return data:sub(2)
end

local reqid = math.random(1000,9999)
local rpcidsTranslate = "MkEWBc"
local rootURL = "https://translate.google.com/"
local executeURL = "https://translate.google.com/_/TranslateWebserverUi/data/batchexecute"
local fsid, bl

do
    local InitialReq = got(rootURL)
    local body = (InitialReq.Body or InitialReq.body or "")
    fsid = body:match('"FdrFJe":"(.-)"')
    bl = body:match('"cfb2h":"(.-)"')
end

local function jsonE(o) return HttpService:JSONEncode(o) end
local function jsonD(o) return HttpService:JSONDecode(o) end

local function translate(str, to, from)
    reqid+=10000
    from = from and getISOCode(from) or 'auto'
    to = to and getISOCode(to) or 'en'
    local data = {{str, from, to, true}, {nil}}
    local freq = {{{rpcidsTranslate, jsonE(data), nil, "generic"}}}
    local url = executeURL..'?'..stringifyQuery{rpcids = rpcidsTranslate, ['f.sid'] = fsid, bl = bl, hl="en", _reqid = reqid-10000, rt = 'c'}
    local body = stringifyQuery{['f.req'] = jsonE(freq)}
    local req = got(url, "POST", body)
    local ok, parsed = pcall(function()
        local arr = jsonD((req.Body or req.body):match'%[.-%]\n')
        return jsonD(arr[1][3])
    end)
    if not ok then
        return {text=str, from={language="auto",text=str}, raw=nil}
    end
    local translationData = parsed
    local result = {text = "", from = {language = "", text = ""}, raw = ""}
    result.raw = translationData
    result.text = translationData[2][1][1][6][1][1]
    result.from.language = translationData[3]
    result.from.text = translationData[2][5] and translationData[2][5][1] or ""
    return result
end

local Players = game:GetService("Players")
local LP = Players.LocalPlayer
local TCS = game:GetService("TextChatService")

local function sysChannel()
    local tc = TCS:WaitForChild("TextChannels")
    return tc:FindFirstChild("RBXSystem") or tc:WaitForChild("RBXGeneral")
end

local function sys(msg)
    sysChannel():DisplaySystemMessage(msg)
end

sys("[TR] Chat Translator ready")

local function translateFrom(message)
    local translation = translate(message, YourLang)
    local text
    if translation.from.language ~= YourLang then
        text = translation.text
    end
    return {text, translation.from.language}
end

local function displayIncomingTranslated(msg)
    if not msg.TextSource then return end
    local p = Players:GetPlayerByUserId(msg.TextSource.UserId)
    local name = p and p.Name or tostring(msg.TextSource.UserId)
    local tab = translateFrom(msg.Text)
    local translation = tab[1]
    if translation and translation ~= "" then
        sys("("..(tab[2] and string.upper(tab[2]) or "AUTO")..") [".. name .."]: ".. translation)
    end
end

TCS.MessageReceived:Connect(function(message)
    if not message.TextSource then return end
    if message.TextSource.UserId ~= LP.UserId then
        task.spawn(displayIncomingTranslated, message)
    end
end)

local sendEnabled = false
local target = ""
local input = TCS:WaitForChild("ChatInputBarConfiguration")
while not input.TextBox do task.wait() end
local TextBox = input.TextBox

local function translateTo(message, tgt)
    tgt = tgt:lower()
    local translation = translate(message, tgt, "auto")
    return translation.text
end

local function disableSend()
    sendEnabled = false
    sys("[TR] Sending Disabled")
end

TextBox.FocusLost:Connect(function(enter)
    if enter and TextBox.Text ~= "" then
        local Message = TextBox.Text
        if Message == ">d" then
            disableSend()
            TextBox.Text = ""
        elseif Message:sub(1,1) == ">" and not Message:find(" ") then
            if getISOCode(Message:sub(2)) then
                sendEnabled = true
                target = Message:sub(2)
                sys("[TR] Target "..target:lower())
                TextBox.Text = ""
            else
                sys("[TR] Invalid language")
                TextBox.Text = ""
            end
        end
    end
end)

local MT = getrawmetatable(game)
local NC = MT.__namecall
setreadonly(MT, false)

MT.__namecall = newcclosure(function(self, ...)
    local Method = getnamecallmethod()
    local Args = {...}
    if Method == "SendAsync" and typeof(self) == "Instance" and self:IsA("TextChannel") and sendEnabled and type(Args[1]) == "string" and Args[1] ~= "" then
        local s = Args[1]
        if s:sub(1,1) ~= ">" then
            local ok, translated = pcall(translateTo, s, target)
            if ok and translated and translated ~= "" then
                Args[1] = translated
            end
        end
        return NC(self, unpack(Args))
    end
    return NC(self, ...)
end)

setreadonly(MT, true)